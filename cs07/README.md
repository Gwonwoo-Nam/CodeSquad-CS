## XML Parser

### 학습 내용
<details>
<summary>
XML이란?
</summary>

Extensible Markup Language는 공유 가능한 방식으로 데이터를 정의하고 저장하는 언어. 
Markup Language의 예로는 대표적으로 HTML이 있다.

HTML은 이미 약속된 태그들만 사용 가능하다. 그러나 XML은 임의로 생성하여 사용할 수 있다.
이를 통해서 정보들을 태그로 마크하여 필요한 내용을 함께 저장할 수 있다는 장점이 있다.

- 텍스트 기반, 간결한 데이터 형
- 마크업 언어가 아닌 마크업 언어를 정의하기 위한 언어이다.
- 자신의 어플리케이션에 적합하게 작성 가능
</details>

<details>
<summary>
DOM이란?
</summary>

DOM(Document Object Model)은 XML이나 HTML 문서에 접근하기 위한 API로 W3C 표준 권고안이다.
DOM은 문서 내의 모든 요소를 정의하고, 해당 요소에 접근하는 방법까지 정의한다.

W3C DOM 표준의 3가지 구분
- Core DOM : 모든 문서 타입을 위한 DOM 모델
- HTML DOM : HTML 문서를 위한 DOM 모델
- XML DOM : XML 문서를 위한 DOM 모델

</details>

<details>
<summary>
추상 구문 트리(AST)란?
</summary>

AST는 프로그래밍 언어로 작성된 소스 코드의 추상 구문 구조의 트리이며, 이 트리의 각 노드는 소스코드에서 발생되는 구조를 나타낸다.
쉽게 말하면, 우리가 작성한 소스코드를 문법에 맞게 노드들로 쪼개서 만든 트리이다.
- 추상인 이유?
추상적인 형태이기 때문이 아닌, 코드에 필연적으로 포함되는 괄호, 기타 부호와 같은 코딩 구문을 포함하므로 추상이라고 한다.

컴파일러가 필요한 프로그래밍 언어에서 컴파일 단계 중 구문 분석(Syntax Analyzing) 단계의 결과물.

- JS의 예시
자바 스크립트 코드 - Abstract Syntax Tree - 인터프리터 - 바이트 코드

자바 스크립트 코드를 Scanner(Lexer)를 통해 token 단위로 분리되며,
parser(Syntax Analyzer)를 거쳐 구문을 확인해보고 AST로 변환된다.
</details>

<details>
<summary>
JSON이란?
</summary>

Javascript Object Notation, 자바스크립트 객체 표기법

- 자바스크립트 객체 표기법으로부터 파생된 경량화된 파일 형식, 복잡한 파일 형식보다 파일 교환에 유리하다. 
</details>
<details>
<summary>
컴파일러 이론(Tokenizer, Lexer, Parser)
</summary>

#### 토크나이저
어떤 구문에서 의미있는 요소들을 토큰으로 쪼개는 역할을 한다.
토큰이란, 어휘 분석의 단위를 의미하는 컴퓨터 용어로 일반적으로 의미있는 단위로 지정된다.

- 토큰 종류
  - identifier : 식별자
  - keyword : 예약어
  - separator : 글자를 구분하는 문자
  - operator : 연산을 위한 심볼
  - literal : 숫자, 논리, 문자
  - comment : 줄, 블록 주

#### 렉서
분해된 토큰의 의미를 분석하는 역할, 토크나이저와 렉서의 역할을 합하여
Lexical Analyze라고 한다. 의미있는 조각을 검출하여 토큰을 생성하는 것이다.
토큰 단위로 생성된 데이터를 parser에게 넘겨준다.

#### 파서
  - 파싱(구문 분석)은 프로그래밍 언어의 문법에 맞게 작성된 텍스트 문서를 읽어 들여 실행하기 위해 텍스트 문서의 문자열을 토큰으로 분해(어휘 분석), 의미와 구조를 반영해 트리 구조의 자료구조인 파스 트리를 생성하는 일련의 과정.
  - 데이터를 구조적으로 바꾸는 과정에서 데이터가 올바른지 검증하는 역할도 수행한다.
  - 일반적으로 파싱이 완료된 후에는 파스 트리를 기반으로 중간 언어인 바이트 코드를 생성하고 실행한다.
</details>


<details>
<summary>브라우저의 렌더링 과정</summary>

위의 개념들을 결합해서 브라우저가 어떻게 렌더링을 수행하는지 알아보자.
![img](https://velog.velcdn.com/images%2Fhang_kem_0531%2Fpost%2Fee083565-ee8f-46c3-a8d1-1e78f65e70b5%2Fimage.png)
1. 브라우저는 HTML, CSS, JS 등 렌더링에 필요한 리소스를 요청하고 서버로부터 응답을 받는다.
2. 브라우저 렌더링 엔진은 서버로부터 응답된 HTML과 CSS를 파싱하여 DOM(HTML), CSSOM(CSS)를 생성하고 결합하여 렌더 트리를 생성한다.
3. 브라우저의 JS 엔진은 서버로부터 응답된 JS 코드를 파싱하여 AST를 생성, 바이트코드로 변환하여 실행한다.
  - 이 때, DOM API를 통해 DOM, CSSOM을 변경할 수 있다. 변경된 DOM, CSSOM은 렌더 트리로 결합된다.
4. 렌더 트리를 기반으로 HTML 레이아웃을 계산하고 화면에 페인팅한다.

https://velog.io/@hang_kem_0531/TIL-%EB%AA%A8%EB%8D%98-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-Deep-Dive-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EC%9D%98-%EB%A0%8C%EB%8D%94%EB%A7%81-%EA%B3%BC%EC%A0%95
</details>

<details>
<summary>
오토마타 이론
</summary>

#### 오토마타란?
- 계산 능력을 갖춘 추상적 연산 장치, 기계
- 오토마타 이론 : 추상적인 연산 장치가 계산할 수 있는 것과 그렇지 않은 것에 대한 이론

#### 형식 언어의 정의
- 언어도 오토마톤에 입력할 수 있을까?
- 모호한 자연어 대신 형식대로 구성된 언어는 기계도 이해할 수 있다.(인공지능 언어)

#### 형식 문법
- 형식 언어를 정의하는 방법, 유한 개의 규칙을 통해 어떤 문자열이 특정 언어에 포함되는지를 판단, 문법으로부터 어떤 문자열을 생성해낼지 결정.
- 생성 문법 : 형식 문법에서 해당 형식 언어의 문자열 생성
- 해석 문법 : 어떤 문자열이 특정 언어에 포함되는지 판단

#### 형식언어의 요소
- 심볼 : 언어의 기본적인 단위, 기호
- 알파벳 : 심볼의 비어있지 않은 유한한 집합(한글, 영어의 알파벳)으로 시그마로 표현
- 문자열 : 선택된 알파벳에서 선택하여 나열한 유한한 심볼들
- 언어 : 어떤 알파벳 시그마 스타의 부분 집합
  - 시그마 스타 : 해당 알파벳에서 만들 수 있는 모든 문자열 집합(무한 집합)

#### 촘스키 위계
- 어떤 스펙을 가진 오토마타는 입력받은 문자열이 어떤 형식 언어에 속하는 문자열인지 판별할 수 있다는 계산 가능성 이론
- 유한 오토마타 : 정규 언어를 인식할 수 있는 오토마타, 가장 좁은 범위의 형식 언어를 인식할 수 있다.

#### 유한 오토마타
- 유한한 개수의 상태를 가지는 오토마타
- 임의의 시각 t에 단 하나의 상태만 가질 수 있다.
- 유한한 오토마타가 어느 상태에서 다른 상태로 변화하는 것을 전이라고 한다.
- 유한 오토마타라는 추상적인 기계를 문자열을 입력받아 언어에 포함된 문자열인지 판단하는 인식기의 역할
- 기억 공간의 한계로 유한 오토마타가 인식할 수 있는 언어는 한정적, 유한 오토마타가 인식할 수 있는 언어를 정규 언어라고 정의한다.

#### 유한 오토마타의 구성
- Q(상태의 집합) : 가질 수 있는 유한한 상태의 집합
- Sigma : 입력으로 주어지는 알파벳
- q0 : 시작 상태
- F : 마지막 상태, 입력 직후 마지막 상태이면 받아들여진다고 판단한다. 여러 개일 수 있다.
- delta : 전이함수, 어떤 상태에서 입력이 주어지면, 다른 상태로 전이

#### 유한 오토마타의 유형
- 결정적 유한 오토마타(DFA)
한 입력에 대해서 무조건 하나의 전이만 가능한 경우에 해당한다. 모든 상태에서 모든 알파벳에 대해 전이 함수가 한가지로만 정의되어있다.
- 비결정적 유한 오토마타(NFA)
한 입력에 대해 여러가지 경로가 존재하거나, 아무 경로도 존재하지 않을 수 있다.
- ε-전이가 있는 비결정적 유한 오토마타(ε-NFA)
앱실론 전이는 입력이 앱실론인 전이함수를 의미한다. 즉, 아무것도 입력하지 않아도 상태 q0에서 q1으로 전이할 수 있음을 의미한다.
기본적으로 모든 상태는 앱실론이 입력되면 그 상태를 그대로 유지한다. (생략된 전이)

#### 정규 표현식
형식 언어 L에 대해 유한 오토마타에 의해 규칙성을 인정받은 언어를 정규 언어라고 할 수 있다. 정규 언어는 규칙을 가지며, 정규 표현식에 의해 표현 가능하다.
정규 언어는 어떤 규칙을 가지고 있고, 정규 표현식을 이용해서 표현 가능하다. 즉, 정규 표현식은 정규 언어를 표현하는 또다른 방법이다.

#### 정규 표현식과 유한 오토마타
- 정규 표현과 유한 오토마타 사이에는 정규 언어라는 접점이 존재한다.
- 정규 표현은 정규 언어를 생성한다.(생성기)
- 유한 오토마타는 정규 언어를 확인한다.(인식기)
- 정규 표현과 유한 오토마타는 동등하다.
- 즉, 정규 언어를 동등한 유한 오토마타, 정규 표현으로 나타낼 수 있다.

#### 문맥 자유 언어
- 정규 언어가 표현할 수 있는 언어를 포함해서 더 많은 언어를 표현할 수 있음을 의미
- 문맥 자유 언어를 표현하는 2가지 방법
1. 푸쉬다운 오토마타(인식기)
2. 문맥 자유 문법(Context Free Language)

#### 문맥 자유 문법
형식 문법의 한 종류로, 대부분의 프로그래밍 언어 문법은 문맥 자유 문법에 속한다.
정규 표현식보다 계층 높고, 많은 언어를 표현가능하다.

G = (V,T,P,S)로 정의한다.
V는 변수, T는 단말의 집합, P는 생성 규칙의 집합, S는 시작 변수이다.

어떤 문자열이 특정 문맥 자유 문법에 속했는 지 확인하는 방법
1. 유도 : 시작 변수에서 해당 문자열을 생성하는 것을 보이는 것
2. 재귀적 추론 : 문자열에서 시작해 시작 변수로 거슬러 올라가는 것

</details>

<details>
<summary>
Stack 구현하기
</summary>

</details>

### 기능 구현 목록

- [O] 입력받은 String을 Token화하여 배열로 반환한다.
- [O] 분해된 토큰의 의미를 분석한다.
- [O] 의미와 구조를 반영해 트리 구조의 파스 트리(DOM)로 생성한다.
  - [O] 태그가 적절하지 않으면 에러를 출력한다.
- [O] 출력양식에 맞추어 문자열로 반환한다.
- DOM 구조를 생성했으면, DOM 구조를 탐색해서 찾아내는 메소드를 구현할 수 있다
1. elementByAttribute 요구사항
- 태그의 속성과 값을 비교해서 해당 요소를 찾는 함수를 구현한다.
2. elementByTag 요구사항
- 태그로 모든 해당 요소를 찾아 배열로 리턴하는 함수를 구현한다.

### 구현 결과

Tokenizer 구현 결과
```
<!DOCTYPE html>
<HTML lang="ko">
  <BODY>
    <P>PORO
	  <IMG SRC="porolog.tistory.com"></IMG>
	  <BR/>
	</P>
  </BODY>
</HTML>

<![<, !, DOCTYPE, html, >, <, HTML, lang, =, ko, >, <, BODY, >, <, P, >, PORO, <, IMG, SRC, =, porolog.tistory.com, >, <, /IMG, >, <, BR/, >, <, /P, >, <, /BODY, >, <, /HTML, >]>
```


Parser 구현
```
{ 
element: 'HTML',
attributes: [
	{
	name : lang, value : "ko"
	}
]
children : [
	{ 
	element: 'BODY',
	children : [
		{ 
		element: 'P',
		text : 'PORO' ,
		children : [
			{ 
			element: 'IMG',
			attributes: [
				{
				name : SRC, value : "porolog.tistory.com"
				}
			]
            element: 'BR'
			]
		}
		]
	}
	]
}
```
